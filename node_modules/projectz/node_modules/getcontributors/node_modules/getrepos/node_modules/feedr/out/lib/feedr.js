// Generated by CoffeeScript 1.9.1
(function() {
  var Feedr, TaskGroup, eachr, extendr, pathUtil, request, safefs, safeps, typeChecker,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  extendr = require('extendr');

  eachr = require('eachr');

  TaskGroup = require('taskgroup').TaskGroup;

  typeChecker = require('typechecker');

  safefs = require('safefs');

  safeps = require('safeps');

  pathUtil = require('path');

  request = require('request');

  Feedr = (function() {
    Feedr.Feedr = Feedr;

    Feedr.create = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this.Feedr, args, function(){});
    };

    Feedr.subclass = require('csextends');

    Feedr.prototype.config = {
      log: null,
      cache: 1000 * 60 * 60 * 24,
      tmpPath: null,
      requestOptions: null,
      plugins: null
    };

    function Feedr(config) {
      var feedr;
      feedr = this;
      this.config = extendr.deepExtend({}, this.config, config);
      safeps.getTmpPath(function(err, tmpPath) {
        if (err) {
          return console.error(err);
        }
        feedr.config.tmpPath = tmpPath;
      });
      this;
    }

    Feedr.prototype.log = function() {
      var args, base;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (typeof (base = this.config).log === "function") {
        base.log.apply(base, args);
      }
      return this;
    };

    Feedr.prototype.readFeeds = function() {
      var arg, args, defaultfeed, failures, feedr, feeds, index, j, len, next, result, tasks;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      feedr = this;
      failures = [];
      feeds = null;
      defaultfeed = {};
      next = null;
      for (index = j = 0, len = args.length; j < len; index = ++j) {
        arg = args[index];
        switch (true) {
          case typeChecker.isFunction(arg):
            next = arg;
            break;
          case typeChecker.isArray(arg):
            feeds = arg;
            break;
          case typeChecker.isPlainObject(arg):
            if (index === 0) {
              feeds = arg;
            } else {
              extendr.extend(defaultfeed, arg);
            }
        }
      }
      result = {};
      tasks = new TaskGroup({
        concurrency: 0,
        onError: 'ignore'
      }).done(function() {
        var err, feed, message;
        message = 'Feedr finished fetching';
        if (failures.length !== 0) {
          message += ("with " + failures.length + " failures:\n") + failures.map(function(i) {
            return i.message;
          }).join('\n');
          err = new Error(message);
          feedr.log('warn', err);
        } else {
          feedr.log('debug', message);
        }
        if (typeChecker.isArray(feeds)) {
          result = (function() {
            var k, len1, results;
            results = [];
            for (index = k = 0, len1 = feeds.length; k < len1; index = ++k) {
              feed = feeds[index];
              results.push(result[index]);
            }
            return results;
          })();
        }
        return next(err, result);
      });
      eachr(feeds, function(feed, index) {
        return tasks.addTask(function(complete) {
          if (typeChecker.isString(feed)) {
            feed = {
              url: feed
            };
          }
          feeds[index] = feed = extendr.deepExtend({}, defaultfeed, feed);
          return feedr.readFeed(feed, function(err, data) {
            if (err) {
              feedr.log('warn', "Feedr failed to fetch [" + feed.url + "] to [" + feed.path + "]", err.stack);
              failures.push(err);
            } else {
              result[index] = data;
            }
            return complete(err);
          });
        });
      });
      tasks.run();
      return this;
    };

    Feedr.prototype.prepareFeed = function(feed) {
      var feedr;
      feedr = this;
      if (feed.hash == null) {
        feed.hash = require('crypto').createHash('md5').update("feedr-" + JSON.stringify(feed.url)).digest('hex');
      }
      if (feed.basename == null) {
        feed.basename = pathUtil.basename(feed.url.replace(/[?#].*/, ''));
      }
      if (feed.extension == null) {
        feed.extension = pathUtil.extname(feed.basename);
      }
      if (feed.name == null) {
        feed.name = feed.hash + feed.extension;
      }
      if (feed.path == null) {
        feed.path = pathUtil.join(feedr.config.tmpPath, feed.name);
      }
      if (feed.metaPath == null) {
        feed.metaPath = pathUtil.join(feedr.config.tmpPath, feed.name) + '-meta.json';
      }
      if (feed.cache == null) {
        feed.cache = feedr.config.cache;
      }
      if (feed.parse == null) {
        feed.parse = true;
      }
      if (feed.parse === 'raw') {
        feed.parse = false;
      }
      if (feed.checkResponse != null) {
        if (feed.check == null) {
          feed.check = feed.checkResponse;
        }
      }
      return feed;
    };

    Feedr.prototype.cleanData = function(data) {
      var key, keys, value;
      keys = [];
      for (key in data) {
        if (!hasProp.call(data, key)) continue;
        value = data[key];
        if (typeChecker.isPlainObject(data)) {
          data[key] = this.cleanData(value);
        }
        keys.push(key);
      }
      if (keys.length === 1 && keys[0] === '_content') {
        data = data._content;
      }
      return data;
    };

    Feedr.prototype.readFeed = function() {
      var arg, args, checkResponse, feed, feedr, generateChecker, generateParser, invalidCheckError, invalidParseError, j, len, next, noUrlError, parseResponse, plugins, readFile, readMetaFile, ref, ref1, ref2, ref3, requestOptions, url, viaCache, viaRequest, writeFeed;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      feedr = this;
      next = null;
      for (j = 0, len = args.length; j < len; j++) {
        arg = args[j];
        switch (true) {
          case typeChecker.isString(arg):
            url = arg;
            break;
          case typeChecker.isFunction(arg):
            next = arg;
            break;
          case typeChecker.isPlainObject(arg):
            feed = arg;
        }
      }
      if (feed == null) {
        feed = {};
      }
      if (url != null) {
        feed.url = url;
      }
      if (!feed.url) {
        noUrlError = new Error('Feed url was not supplied');
        return next(noUrlError);
      }
      feed = this.prepareFeed(feed);
      plugins = {};
      if ((ref = feed.plugins) != null ? ref.length : void 0) {
        feed.plugins.forEach(function(name, index) {
          var err;
          try {
            return plugins[index] = require('feedr-plugin-' + name);
          } catch (_error) {
            err = _error;
            next(err);
            return false;
          }
        });
      } else {
        plugins = require(__dirname + '/plugins');
      }
      generateParser = function(name, method, opts, next) {
        feedr.log('debug', "Feedr parse [" + feed.url + "] with " + name + " attempt");
        return method(opts, function(err, data) {
          if (err) {
            return next(err);
          }
          if (data) {
            feedr.log('debug', "Feedr parse [" + feed.url + "] with " + name + " attempt, used");
            opts.data = data;
          } else {
            feedr.log('debug', "Feedr parse [" + feed.url + "] with " + name + " attempt, ignored");
          }
          return next(null, data);
        });
      };
      generateChecker = function(name, method, opts, next) {
        feedr.log('debug', "Feedr check [" + feed.url + "] with " + name + " attempt");
        return method(opts, function(err) {
          if (err) {
            return next(err);
          }
          feedr.log('debug', "Feedr check [" + feed.url + "] with " + name + " attempt, success");
          return next(null, data);
        });
      };
      if (typeof feed.parse === 'string') {
        if (typeof ((ref1 = plugins[feed.parse]) != null ? ref1.parse : void 0) === 'function') {
          parseResponse = generateParser.bind(null, feed.parse, plugins[feed.parse].parse);
        } else {
          invalidParseError = new Error('Invalid parse value: ' + feed.parse);
          return next(invalidParseError);
        }
      } else if (typeof feed.parse === 'function') {
        parseResponse = generateParser.bind(null, 'custom', feed.parse);
      } else if (feed.parse === true) {
        parseResponse = function(opts, parseComplete) {
          var checkTasks;
          checkTasks = new TaskGroup().done(parseComplete);
          eachr(plugins, function(value, key) {
            if (value.parse != null) {
              return checkTasks.addTask(function(parseTaskComplete) {
                return generateParser.bind(null, key, value.parse)(opts, function(err, data) {
                  if (data) {
                    checkTasks.clear();
                  }
                  return parseTaskComplete(err);
                });
              });
            }
          });
          return checkTasks.run();
        };
      } else {
        parseResponse = function(opts, parseComplete) {
          return parseComplete();
        };
      }
      if (typeof feed.check === 'string') {
        if (typeof ((ref2 = plugins[feed.check]) != null ? ref2.check : void 0) === 'function') {
          checkResponse = generateChecker.bind(null, feed.check, (ref3 = plugins[feed.check]) != null ? ref3.check : void 0);
        } else {
          invalidCheckError = new Error('Invalid check value: ' + feed.check);
          return next(invalidCheckError);
        }
      } else if (typeof feed.check === 'function') {
        checkResponse = generateChecker.bind(null, 'custom', feed.check);
      } else if (feed.check === true) {
        checkResponse = function(opts, checkComplete) {
          var checkTasks;
          checkTasks = new TaskGroup().done(checkComplete);
          eachr(plugins, function(value, key) {
            if (value.check != null) {
              return checkTasks.addTask(function(checkTaskComplete) {
                return generateChecker.bind(null, key, value.check)(opts, checkTaskComplete);
              });
            }
          });
          return checkTasks.run();
        };
      } else {
        checkResponse = function(opts, checkComplete) {
          return checkComplete();
        };
      }
      requestOptions = extendr.deepExtend({
        url: feed.url,
        timeout: 1 * 60 * 1000,
        encoding: null,
        headers: {
          'User-Agent': 'Wget/1.14 (linux-gnu)'
        }
      }, feedr.config.requestOptions || {}, feed.requestOptions || {});
      readFile = function(path, readFileComplete) {
        feedr.log('debug', "Feedr is reading [" + feed.url + "] on [" + path + "], checking exists");
        return safefs.exists(path, function(exists) {
          if (!exists) {
            feedr.log('debug', "Feedr is reading [" + feed.url + "] on [" + path + "], it doesn't exist");
            return readFileComplete();
          }
          feedr.log('debug', "Feedr is reading [" + feed.url + "] on [" + path + "], it exists, now reading");
          return safefs.readFile(path, null, function(err, rawData) {
            if (err) {
              feedr.log('debug', "Feedr is reading [" + feed.url + "] on [" + path + "], it exists, read failed", err.stack);
              if (err) {
                return readFileComplete(err);
              }
            }
            feedr.log('debug', "Feedr is reading [" + feed.url + "] on [" + path + "], it exists, read completed");
            return readFileComplete(null, rawData);
          });
        });
      };
      readMetaFile = function(path, readMetaFileComplete) {
        feedr.log('debug', "Feedr is parsing [" + feed.url + "] on [" + path + "]");
        return readFile(path, function(err, rawData) {
          var data;
          if (err || !rawData) {
            feedr.log('debug', "Feedr is parsing [" + feed.url + "] on [" + path + "], read failed", err != null ? err.stack : void 0);
            return readMetaFileComplete(err);
          }
          try {
            data = JSON.parse(rawData.toString());
          } catch (_error) {
            err = _error;
            feedr.log('warn', "Feedr is parsing [" + feed.url + "] on [" + path + "], parse failed", err.stack);
            return readMetaFileComplete(err);
          }
          feedr.log('debug', "Feedr is parsing [" + feed.url + "] on [" + path + "], parse completed");
          return readMetaFileComplete(null, data);
        });
      };
      writeFeed = function(response, data, writeFeedComplete) {
        var writeTasks;
        feedr.log('debug', "Feedr is writing [" + feed.url + "] to [" + feed.path + "]");
        writeTasks = new TaskGroup({
          concurrency: 0
        }).done(function(err) {
          if (err) {
            feedr.log('warn', "Feedr is writing [" + feed.url + "] to [" + feed.path + "], write failed", err.stack);
            return writeFeedComplete(err);
          }
          feedr.log('debug', "Feedr is writing [" + feed.url + "] to [" + feed.path + "], write completed");
          return writeFeedComplete(null, data);
        });
        writeTasks.addTask('store the meta data in a cache somewhere', function(writeTaskComplete) {
          var writeData;
          writeData = JSON.stringify({
            headers: response.headers,
            parse: feed.parse
          }, null, '  ');
          return safefs.writeFile(feed.metaPath, writeData, writeTaskComplete);
        });
        writeTasks.addTask('store the parsed data in a cache somewhere', function(writeTaskComplete) {
          var writeData;
          if (feed.parse) {
            writeData = JSON.stringify(data);
          } else {
            writeData = data;
          }
          return safefs.writeFile(feed.path, writeData, writeTaskComplete);
        });
        return writeTasks.run();
      };
      viaCache = function(viaCacheComplete) {
        var data, meta, readTasks;
        feedr.log('debug', "Feedr is remembering [" + feed.url + "] from cache");
        meta = null;
        data = null;
        readTasks = new TaskGroup().done(function(err) {
          return viaCacheComplete(err, data, meta != null ? meta.headers : void 0);
        });
        readTasks.addTask('read the meta data in a cache somewhere', function(viaCacheTaskComplete) {
          return readMetaFile(feed.metaPath, function(err, result) {
            if (err || !result) {
              return viaCacheTaskComplete(err);
            }
            meta = result;
            return viaCacheTaskComplete();
          });
        });
        readTasks.addTask('read the parsed data in a cache somewhere', function(viaCacheTaskComplete) {
          return readFile(feed.path, function(err, rawData) {
            if (err || !rawData) {
              return viaCacheTaskComplete(err);
            }
            if (feed.parse === false || (feed.parse === true && meta.parse === false)) {
              data = rawData;
            } else {
              try {
                data = JSON.parse(rawData.toString());
              } catch (_error) {
                err = _error;
                return viaCacheTaskComplete(err);
              }
            }
            return viaCacheTaskComplete();
          });
        });
        return readTasks.run();
      };
      viaRequest = function(viaRequestComplete) {
        var base, ref4;
        feedr.log('debug', "Feedr is fetching [" + feed.url + "] to [" + feed.path + "], requesting");
        if (feed.cache && ((ref4 = feed.metaData) != null ? ref4.etag : void 0)) {
          if ((base = requestOptions.headers)['If-None-Match'] == null) {
            base['If-None-Match'] = feed.metaData.etag;
          }
        }
        return request(requestOptions, function(err, response, data) {
          var handleError, opts;
          opts = {
            feedr: feedr,
            feed: feed,
            response: response,
            data: data
          };
          feedr.log('debug', "Feedr is fetching [" + feed.url + "] to [" + feed.path + "], requested");
          handleError = function(err) {
            feedr.log('warn', "Feedr is fetching [" + feed.url + "] to [" + feed.path + "], failed", err.stack);
            if (feed.cache) {
              return viaCache(next);
            }
            return viaRequestComplete(err, opts.data, requestOptions.headers);
          };
          if (err) {
            return handleError(err);
          }
          if (feed.cache && response.statusCode === 304) {
            return viaCache(next);
          }
          return parseResponse(opts, function(err) {
            if (err) {
              return handleError(err);
            }
            feedr.log('debug', "Feedr is fetching [" + feed.url + "] to [" + feed.path + "], requested, checking");
            return checkResponse(opts, function(err) {
              if (err) {
                return handleError(err);
              }
              return writeFeed(response, opts.data, function(err) {
                return viaRequestComplete(err, opts.data, requestOptions.headers);
              });
            });
          });
        });
      };
      if (feed.cache === false) {
        return viaRequest(next);
      }
      readMetaFile(feed.metaPath, function(err, metaData) {
        if (err || !metaData) {
          return viaRequest(next);
        }
        feed.metaData = metaData;
        if (feedr.isFeedCacheStillRelevant(feed, metaData)) {
          return viaCache(next);
        }
        return viaRequest(next);
      });
      return this;
    };

    Feedr.prototype.isFeedCacheStillRelevant = function(feed, metaData) {
      return feed.cache && ((feed.cache === 'preferred') || (metaData.expires && (new Date() < new Date(metaData.expires))) || (typeChecker.isNumber(feed.cache) && metaData.date && (new Date() < new Date(new Date(metaData.date).getTime() + feed.cache))));
    };

    return Feedr;

  })();

  module.exports = Feedr;

}).call(this);
