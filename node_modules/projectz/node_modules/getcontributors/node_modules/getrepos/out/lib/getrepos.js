// Generated by CoffeeScript 1.8.0
(function() {
  var Getter, TaskGroup, extendr, typeChecker,
    __slice = [].slice;

  extendr = require('extendr');

  typeChecker = require('typechecker');

  TaskGroup = require('taskgroup').TaskGroup;

  Getter = (function() {
    Getter.prototype.reposMap = null;

    Getter.prototype.config = null;

    function Getter(opts) {
      var _base, _base1;
      if (opts == null) {
        opts = {};
      }
      this.config = {};
      this.reposMap = {};
      extendr.extend(this.config, opts);
      if ((_base = this.config).githubClientId == null) {
        _base.githubClientId = process.env.GITHUB_CLIENT_ID || null;
      }
      if ((_base1 = this.config).githubClientSecret == null) {
        _base1.githubClientSecret = process.env.GITHUB_CLIENT_SECRET || null;
      }
      this.feedr = new (require('feedr').Feedr)(this.config);
      this;
    }

    Getter.prototype.log = function() {
      var args, _base;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (typeof (_base = this.config).log === "function") {
        _base.log.apply(_base, args);
      }
      return this;
    };

    Getter.prototype.addRepo = function(repo) {
      var _base, _name;
      this.log('debug', 'Adding the repo:', repo);
      if (!(repo != null ? repo.full_name : void 0)) {
        return null;
      }
      if ((_base = this.reposMap)[_name = repo.full_name] == null) {
        _base[_name] = repo;
      }
      return this.reposMap[repo.full_name];
    };

    Getter.prototype.getRepos = function(repos) {
      var comparator, exists;
      this.log('debug', 'Get repos');
      comparator = function(a, b) {
        var A, B;
        A = a.name.toLowerCase();
        B = b.name.toLowerCase();
        if (A === B) {
          return 0;
        } else if (A < B) {
          return -1;
        } else {
          return 1;
        }
      };
      if ((repos != null) === false) {
        repos = this.reposMap;
      } else {
        if (typeChecker.isArray(repos) === true) {
          exists = {};
          repos = repos.filter(function(repo) {
            var _name;
            if (!(repo != null ? repo.full_name : void 0)) {
              return false;
            }
            if (exists[_name = repo.full_name] == null) {
              exists[_name] = 0;
            }
            ++exists[repo.full_name];
            return exists[repo.full_name] === 1;
          });
        }
      }
      if (typeChecker.isPlainObject(repos) === true) {
        repos = Object.keys(repos).map((function(_this) {
          return function(key) {
            return repos[key];
          };
        })(this));
      }
      repos = repos.sort(comparator);
      return repos;
    };

    Getter.prototype.fetchRepos = function(repoFullNames, next) {
      var me, repos, tasks;
      me = this;
      this.log('debug', 'Fetch repos:', repos);
      repos = [];
      tasks = new TaskGroup({
        concurrency: 0
      }).done(function(err) {
        var result;
        if (err) {
          return next(err, []);
        }
        result = me.getRepos(repos);
        return next(null, result);
      });
      repoFullNames.forEach(function(repoFullName) {
        return tasks.addTask(function(complete) {
          return me.requestRepo(repoFullName, {}, function(err, repo) {
            if (err) {
              return complete(err);
            }
            if (repo) {
              repos.push(repo);
            }
            return complete();
          });
        });
      });
      tasks.run();
      return this;
    };

    Getter.prototype.requestRepo = function(repoFullName, opts, next) {
      var feedOptions, feedUrl, me;
      if (opts == null) {
        opts = {};
      }
      me = this;
      feedUrl = "https://api.github.com/repos/" + repoFullName + "?client_id=" + this.config.githubClientId + "&client_secret=" + this.config.githubClientSecret;
      feedOptions = {
        url: feedUrl,
        parse: 'json'
      };
      this.log('debug', 'Requesting repo:', repoFullName, opts, feedUrl);
      this.feedr.readFeed(feedOptions, function(err, repo) {
        var addedRepo;
        if (err) {
          return next(err, {});
        }
        addedRepo = me.addRepo(repo);
        return next(null, addedRepo);
      });
      return this;
    };

    Getter.prototype.fetchReposFromUsers = function(users, next) {
      var query;
      this.log('debug', 'Fetch repos from users:', users);
      query = users.map(function(name) {
        return '@' + name;
      }).join('%20');
      return this.fetchReposFromSearch(query, next);
    };

    Getter.prototype.fetchReposFromSearch = function(query, next) {
      var me;
      me = this;
      if (typeChecker.isArray(query)) {
        query = query.map(function(name) {
          return '@' + name;
        }).join('%20');
      }
      this.log('debug', 'Fetch repos from search:', query);
      this.requestReposFromSearch(query, {
        page: 1
      }, function(err, repos) {
        var result;
        if (err) {
          return next(err, []);
        }
        result = me.getRepos(repos);
        return next(null, result);
      });
      return this;
    };

    Getter.prototype.requestReposFromSearch = function(query, opts, next) {
      var feedOptions, feedUrl, me;
      if (opts == null) {
        opts = {};
      }
      if (opts.page == null) {
        opts.page = 1;
      }
      me = this;
      feedUrl = "https://api.github.com/search/repositories?page=" + opts.page + "&per_page=100&q=" + query + "&client_id=" + this.config.githubClientId + "&client_secret=" + this.config.githubClientSecret;
      feedOptions = {
        url: feedUrl,
        parse: 'json',
        requestOptions: {
          headers: {
            Accept: 'application/vnd.github.beta+json'
          }
        }
      };
      this.log('debug', 'Requesting repos from search:', query, opts, feedUrl);
      this.feedr.readFeed(feedOptions, function(err, data) {
        var addedRepo, addedRepos, repo, _i, _len, _ref, _ref1;
        if (err) {
          return next(err, []);
        }
        if (!(data != null ? (_ref = data.items) != null ? _ref.length : void 0 : void 0)) {
          return next(null, []);
        }
        addedRepos = [];
        _ref1 = data.items;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          repo = _ref1[_i];
          addedRepo = me.addRepo(repo);
          if (addedRepo) {
            addedRepos.push(addedRepo);
          }
        }
        if (data.items.length === 100) {
          opts.page++;
          return me.requestReposFromSearch(query, opts, function(err, moreAddedRepos) {
            var combinedAddedRepos;
            if (err) {
              return next(err, []);
            }
            combinedAddedRepos = addedRepos.concat(moreAddedRepos);
            return next(null, combinedAddedRepos);
          });
        } else {
          return next(null, addedRepos);
        }
      });
      return this;
    };

    return Getter;

  })();

  module.exports = {
    create: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Getter, args, function(){});
    }
  };

}).call(this);
