// Generated by CoffeeScript 1.9.0
(function() {
  module.exports = {
    github: {
      check: function(_arg, next) {
        var data, failedResponseError, feed;
        feed = _arg.feed, data = _arg.data;
        if (feed.url.indexOf('github.com') !== -1 && (data != null ? data.message : void 0)) {
          failedResponseError = new Error(data.message);
          return next(failedResponseError);
        }
        return next();
      }
    },
    xml: {
      parse: function(_arg, next) {
        var data, err, feed, feedr, parser, response, xml2js, xml2jsOptions, _ref;
        feedr = _arg.feedr, feed = _arg.feed, response = _arg.response, data = _arg.data;
        if (!(feed.parse === 'xml' || ((_ref = feed.extension) === '.xml' || _ref === '.atom' || _ref === '.rss' || _ref === '.rdf' || _ref === '.html' || _ref === '.html') || response.headers['content-type'].indexOf('xml') !== -1 || response.headers['content-type'].indexOf('html') !== -1)) {
          return next();
        }
        xml2jsOptions = require('extendr').deepExtend({}, feedr.config.xml2jsOptions || {}, feed.xml2jsOptions || {});
        xml2js = require('xml2js');
        parser = new xml2js.Parser(xml2jsOptions);
        parser.on('end', function(data) {
          return next(null, data);
        });
        try {
          return parser.parseString(data.toString().trim());
        } catch (_error) {
          err = _error;
          return next(err);
        }
      }
    },
    cson: {
      parse: function(_arg, next) {
        var data, feed, response, _ref;
        feed = _arg.feed, response = _arg.response, data = _arg.data;
        if (!(feed.parse === 'cson' || ((_ref = feed.extension) === '.coffee' || _ref === '.cson') || response.headers['content-type'].indexOf('coffeescript') !== -1 || response.headers['content-type'].indexOf('cson') !== -1)) {
          return next();
        }
        return require('CSON').parse(data.toString(), next);
      }
    },
    json: {
      parse: function(_arg, next) {
        var data, err, feed, feedr, response, _ref;
        feedr = _arg.feedr, feed = _arg.feed, response = _arg.response, data = _arg.data;
        if (!(feed.parse === 'json' || ((_ref = feed.extension) === '.json' || _ref === '.jsonp' || _ref === '.js') || response.headers['content-type'].indexOf('javascript') !== -1 || response.headers['content-type'].indexOf('json') !== -1)) {
          return next();
        }
        data = data.toString().trim().replace(/(^([\s\;]|\/\*\*\/)+|[\s\;]+$)/g, '');
        data = data.replace(/^[a-z0-9]+/gi, '').replace(/^\(|\)$/g, '');
        try {
          data = JSON.parse(data);
        } catch (_error) {
          err = _error;
          data = data.replace(/\\'/g, "'");
          try {
            data = JSON.parse(data);
          } catch (_error) {
            err = _error;
            return next(err);
          }
        }
        if (feed.clean) {
          feedr.log('debug', "Feedr is cleaning data from [" + feed.url + "]");
          data = feedr.cleanData(data);
        }
        return next(null, data);
      }
    },
    yaml: {
      parse: function(_arg, next) {
        var data, err, feed, response, _ref;
        feed = _arg.feed, response = _arg.response, data = _arg.data;
        if (!(feed.parse === 'yaml' || ((_ref = feed.extension) === '.yml' || _ref === '.yaml') || response.headers['content-type'].indexOf('yaml') !== -1)) {
          return next();
        }
        try {
          data = require('yamljs').parse(data.toString().trim());
        } catch (_error) {
          err = _error;
          return next(err);
        }
        return next(null, data);
      }
    },
    string: {
      parse: function(_arg, next) {
        var data, feed;
        feed = _arg.feed, data = _arg.data;
        if (!require('istextorbinary').isTextSync(feed.basename, data)) {
          return next();
        }
        return next(null, data.toString());
      }
    }
  };

}).call(this);
