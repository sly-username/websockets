/**
* String Interpolation
**/

.create( @escape; @rules ) {
  @escaped: ~"@{escape}";
  @media @escaped {
    @rules();
  }
}

/**
* And / Or / Guard Operators
**/

.and( @query ){
  @and: "@{query} and";
}

.and2( @query ){
  @and2: "@{query} and";
}

.or( @query ){
  @or: "@{query},";
}

.or2( @query ){
  @or2: "@{query},";
}

.when( @query ){
  @when: "@{query} when";
}

.when2( @query ){
  @when2: "@{query} when";
}

/**
 * Base media types
 *  all, print, screen, speech
 **/

.all(){
  @all: "all";
}

.print(){
  @print: "print";
}

.printOnly(){
  @printOnly: "only print";
}

.screen(){
  @screen: "screen";
}

.screenOnly(){
  @screenOnly: "only screen";
}

.speech(){
  @speech: "speech";
}

.speechOnly(){
  @speechOnly: "only speech";
}


/***
  Media Features

@media (color) { ... }
@media (min-color: 4) { ... }
  has min/max
  value: the number of bits per color component of the device

@media (color-index) { ... }
@media (min-color-index: 256) { ... }
  has min/max
  value: number of entries in the color look-up table
*/

/*
@media (min-aspect-ratio: 1/1) { ... }
  has min/max
  value: The aspect ratio fo the target display area, horizontal px / vertical px
*/
.aspectRatio( @ratio; @query ){
  @aspectRatio: "@{query} (aspect-ratio: @{ratio})";
}

.minAspectRatio( @ratio; @query ){
  @minAspectRatio: "@{query} (min-aspect-ratio: @{ratio})";
}

.maxAspectRatio( @ratio; @query ){
  @maxAspectRatio: "@{query} (max-aspect-ratio: @{ratio})";
}

/*
@media (device-aspect-ratio: 16/9) { ... }
  has min/max
  value: Aspect ratio of the device, horizontal/vertical
*/
.deviceAspectRatio( @ratio; @query ){
  @deviceAspectRatio: "@{query} (device-aspect-ratio: @{ratio})";
}

.minDeviceAspectRatio( @ratio; @query ){
  @minDeviceAspectRatio: "@{query} (min-device-aspect-ratio: @{ratio})";
}

.maxDeviceAspectRatio( @ratio; @query ){
  @maxDeviceAspectRatio: "@{query} (max-device-aspect-ratio: @{ratio})";
}

/*
@media (max-device-height: 799px) { ... }
  has min/max
  value: height of the output device, (screen size, not just rendering area)
*/
.deviceHeight( @height; @query ){
  @deviceHeight: "@{query} (device-height: @{height})";
}

.minDeviceHeight( @height; @query ){
  @minDeviceHeight: "@{query} (min-device-height: @{height})";
}

.maxDeviceHeight( @height; @query ){
  @maxDeviceHeight: "@{query} (max-device-height: @{height})";
}

/*
@media (max-device-width: 799px) { ... }
  has min/max
  value: width of the output device, (screen size, not just rendering area)
*/
.deviceWidth( @width; @query ){
  @deviceWidth: "@{query} (device-width: @{width})";
}

.minDeviceWidth( @width; @query ){
  @minDeviceWidth: "@{query} (min-device-width: @{width})";
}

.maxDeviceWidth( @width; @query ){
  @maxDeviceWidth: "@{query} (max-device-width: @{width})";
}

/*
// No real support yet
@media handheld and (grid) and (max-width: 15em) { ... }
(grid)
  1 if output device is a grid or bitmap device
  0 otherwise
  "em" -- 1em is one cell of the grid horizontally and vertically
*/

/*
@media (height: 10px) { ... }
  has min/max
  height of the device's rendering surface
*/
.queryHeight( @height; @query ){
  @queryHeight: "@{query} (height: @{height})";
}

.minQueryHeight( @height; @query ){
  @minQueryHeight: "@{query} (min-height: @{height})";
}

.maxQueryHeight( @height; @query ){
  @maxQueryHeight: "@{query} (max-height: @{height})";
}

/*
@media (min-width: 500px) and (max-width: 800px) { ... }
  has min/max
  value: the width of the rendering surface
*/
.queryWidth( @width; @query ){
  @queryWidth: "@{query} (width: @{width})";
}

.minQueryWidth( @width; @query ){
  @minQueryWidth: "@{query} (min-width: @{width})";
}

.maxQueryWidth( @width; @query ){
  @maxQueryWidth: "@{query} (max-width: @{width})";
}

/*
@media (monochrome) { ... }
  has min/max
  value: number of bits per pixel, 0 if not monochrome device
*/
.monochrome( @bitsPerPixel; @query ){
  @monochrome: "@{query} (monochrome: @{bitsPerPixel})";
}

.minMonochrome( @bitsPerPixel; @query ){
  @minMonochrome: "@{query} (min-monochrome: @{bitsPerPixel})";
}

.maxMonochrome( @bitsPerPixel; @query ){
  @maxMonochrome: "@{query} (max-monochrome: @{bitsPerPixel})";
}

/*
@media (orientation: portrait) { ... }
  value: landscape | portrait
  landscape: the display is wider than it is tall
  portrait: the display is taller than it is wide
*/
.landscapeOrientation( @query ){
 @landscapeOrientation: "@{query} (orientation: landscape)";
}

.portraitOrientation( @query ){
  @portraitOrientation: "@{query} (orientation: portrait)";
}

/*
@media (resolution) { ... }
  has min/max
  value: resolution in dpi or dpcm
  indicates the pixel density of the device
*/
.resolution( @density; @query ){
  @resolution: "@{query} (resolution: @{density})";
}

.minResolution( @density; @query ){
  @minResolution: "@{query} (min-resolution: @{density})";
}
.maxResolution( @density; @query ){
  @maxResolution: "@{query} (max-resolution: @{density})";
}

//TODO make mixin for the following
.resolution( high; @rules ){
  .resolution( 2dppx; @rules );
}

.monochrome( @rules ) when (isruleset(@rules)){
  @media (monochrome) {
    @rules();
  }
}

/*
// No real support yet, since TV is not supported
@media (scan: progressive | interlace) // tv only
  scanning process of TV outputs
*/
